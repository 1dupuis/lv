<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lumière Vivante - Avis Clients Élogieux</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:ital,wght@0_300;0_400;0_600;1_300&display=swap" rel="stylesheet">
    <style>
        @keyframes gradientBG {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            font-size: 16px;
        }

        body {
            background: linear-gradient(-45deg, #020207, #080610, #000000, #0f0514);
            background-size: 400% 400%;
            animation: gradientBG 35s ease infinite;
            color: #f0f0f0;
            font-family: 'Poppins', sans-serif;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            text-align: center;
            overflow: hidden;
            padding: 1.5rem 1rem;
        }

        .review-container {
            max-width: 90%;
            width: 780px;
            padding: 3.2rem 2.2rem; /* Fine-tuned padding */
            background: rgba(16, 16, 26, 0.75);
            backdrop-filter: blur(16px);
            border-radius: 22px; /* Slightly larger radius */
            box-shadow: 0 14px 50px rgba(0, 0, 0, 0.45),
                        inset 0 1px 2px rgba(0, 0, 0, 0.1), /* Subtle inner top shadow */
                        inset 0 -1px 1px rgba(255, 255, 255, 0.02); /* Subtle inner bottom highlight */
            border: 0px solid;
            border-image-source: linear-gradient(140deg, rgba(255, 255, 255, 0.2), rgba(255, 255, 255, 0.05));
            border-image-slice: 1;
            margin-bottom: 100px;
            position: relative;
        }

        .review-content {
            min-height: 210px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        .review-rating {
             font-size: 1.45rem;
             color: #F0C040; /* Clearer gold */
             margin-bottom: 1.4rem;
             opacity: 0;
             transform: translateY(15px);
             will-change: opacity, transform;
             letter-spacing: 4px;
             text-shadow: 0 0 10px rgba(240, 192, 64, 0.25); /* Refined glow */
        }

        .review-text {
            font-size: clamp(1.2rem, 2.7vw, 1.7rem);
            font-weight: 400;
            line-height: 1.85;
            color: #FCFCFC; /* Bright clean white */
            margin-bottom: 1.7rem;
            opacity: 0;
            transform: translateY(15px);
            will-change: opacity, transform, filter;
            font-style: italic;
            max-width: 96%;
        }

        .reviewer-name {
            font-size: clamp(0.9rem, 1.7vw, 1.0rem);
            font-weight: 300;
            color: #C0C0E0; /* Slightly more contrast */
            opacity: 0;
            transform: translateY(15px);
            will-change: opacity, transform, filter;
            font-style: normal;
            margin-top: 0.3rem; /* Reduced space */
        }

        .status-message {
            font-size: 1.05rem; /* Slightly smaller */
            font-weight: 300;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #A0A0B0; /* Neutral status color */
            opacity: 0; /* Start hidden */
            transition: color 0.3s ease; /* Transition color changes */
            width: 85%;
            pointer-events: none;
            visibility: hidden; /* Use visibility to prevent layout shifts */
        }

        .status-message.visible {
             visibility: visible; /* Make visible */
        }

        .status-message.error {
             color: #ff9a9a; /* Brighter, clearer error red */
             font-weight: 400;
        }

        .presentation-button {
            position: fixed;
            bottom: 35px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            display: inline-block;
            padding: 14px 34px;
            background-image: linear-gradient(to bottom, #DABF60, #CFAE4E); /* Gradient background */
            color: #101013; /* Darker text */
            font-family: 'Poppins', sans-serif;
            font-size: 1.05rem;
            font-weight: 500;
            text-decoration: none;
            border: none; /* Remove default border */
            border-top: 1px solid rgba(255, 255, 255, 0.15); /* Subtle top highlight */
            border-bottom: 1px solid rgba(0, 0, 0, 0.1); /* Subtle bottom shadow */
            border-radius: 10px;
            cursor: pointer;
            transition: transform 0.25s ease, box-shadow 0.35s ease, background-image 0.3s ease;
            box-shadow: 0 7px 22px rgba(0, 0, 0, 0.3), 0 1px 1px rgba(255, 255, 255, 0.05) inset; /* Enhanced shadow */
        }

        .presentation-button:hover {
            background-image: linear-gradient(to bottom, #E0C870, #DABF60); /* Lighter gradient */
            transform: translateX(-50%) translateY(-4px);
            box-shadow: 0 11px 30px rgba(218, 191, 96, 0.4), 0 1px 1px rgba(255, 255, 255, 0.08) inset; /* Brighter glow */
        }

         .presentation-button:active {
             transform: translateX(-50%) translateY(-1px);
             background-image: linear-gradient(to top, #DABF60, #CFAE4E); /* Invert gradient slightly */
             box-shadow: 0 5px 18px rgba(0, 0, 0, 0.25), 0 1px 2px rgba(0, 0, 0, 0.1) inset; /* Pressed shadow */
         }

    </style>
</head>
<body>

    <div class="review-container">
        <div class="review-content">
            <p class="review-rating" id="review-rating"></p>
            <p class="review-text" id="review-text"></p>
            <p class="reviewer-name" id="reviewer-name"></p>
            <p class="status-message" id="status-message"></p>
        </div>
    </div>

    <a href="/presentation" class="presentation-button">
        Découvrir la Présentation
    </a>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js" defer></script>

    <script>
        const apiKey = "AIzaSyAtIJNuqJsnifU3Ez3CNEtjUrhQWbB1N7o"; // PRODUCTION WARNING: Secure this key!
        const modelName = "gemini-2.0-flash-lite";
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${modelName}:generateContent?key=${apiKey}`;
        const REVIEW_INTERVAL_MS = 2500;
        const SEPARATOR = ' :: ';
        const STAR_RATING = '★★★★★';
        const BATCH_SIZE = 5;

        const reviewRatingElement = document.getElementById('review-rating');
        const reviewTextElement = document.getElementById('review-text');
        const reviewerNameElement = document.getElementById('reviewer-name');
        const statusMessageElement = document.getElementById('status-message');
        const elementsToAnimate = [reviewRatingElement, reviewTextElement, reviewerNameElement];

        let localReviewsBatch = [];
        let nextReviewsBatch = null;
        let currentBatchIndex = 0;
        let isFetching = false;
        let intervalId = null;

        console.warn("DEMO ONLY: API Key is exposed directly in the frontend code. Do not use this method in production.");

        function setStatus(message, isError = false) {
            statusMessageElement.textContent = message;
            statusMessageElement.classList.toggle('error', isError);
            statusMessageElement.classList.add('visible');
            gsap.to(statusMessageElement, { opacity: 1, duration: 0.4 });
        }

        function hideStatus() {
            gsap.to(statusMessageElement, { opacity: 0, duration: 0.4, onComplete: () => {
                statusMessageElement.classList.remove('visible', 'error');
                statusMessageElement.textContent = '';
            }});
        }

        async function fetchNewReviewsBatchInternal() {
             const prompt = `Génère exactement ${BATCH_SIZE} paires uniques 'avis client :: nom client'. Chaque avis doit être une critique client détaillée et enthousiaste pour la marque de luxe 'Lumière Vivante', exprimant une profonde satisfaction et un sentiment de luxe authentique. L'avis DOIT : 1. Mentionner la qualité exceptionnelle perçue (matière somptueuse, finitions parfaites, tombé impeccable, design unique/intemporel). 2. Décrire le sentiment procuré (se sentir spécial(e), confiant(e), rayonnant(e), élégant(e) sans effort, version améliorée de soi-même). 3. Faire allusion à un type d'article ou catégorie (mon nouveau manteau cachemire, cette robe soirée fluide, un accessoire signature, le chemisier soie aérien, ce tailleur structuré) sans nom spécifique. 4. Optionnellement, mentionner un contexte positif (idéal pour X, cadeau marquant, service boutique remarquable, investissement mode quotidien). 5. Utiliser un ton chic, personnel, sincère. Éviter superlatifs vides. Longueur: 2-4 phrases courtes. Chaque nom client = nom fictif, consonance française élégante (prénom nom). Utilise '${SEPARATOR}' comme séparateur exact. Pas de guillemets autour de l'avis. Une paire par ligne.

Exemple format :
Ce nouveau manteau Lumière Vivante est une pure merveille. La laine est d'une douceur incroyable et la coupe me donne une allure folle, je me sens si élégante !${SEPARATOR}Isabelle Renaud
J'ai reçu cette étole en cachemire en cadeau... Quelle délicatesse ! Elle rehausse la moindre tenue et me fait sentir spéciale à chaque fois que je la porte.${SEPARATOR}Antoine Chevalier
Enfin trouvé le tailleur parfait ! Le tissu est sublime, le tombé impeccable. Un investissement qui me donne une confiance incroyable pour mes rendez-vous importants.${SEPARATOR}Chloé Dubois
Cette robe de cocktail Lumière Vivante était la star de la soirée. Les finitions sont exquises, je n'ai eu que des compliments et je me sentais absolument rayonnante.${SEPARATOR}Maxime Lefebvre
Le service en boutique était exceptionnel, ils m'ont aidé à choisir ce chemisier en soie unique. La matière est divine sur la peau, je suis conquise par la marque.${SEPARATOR}Léa Martin`;

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: prompt }] }],
                        generationConfig: { temperature: 0.8, maxOutputTokens: 600 },
                        safetySettings: [
                          { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                          { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                          { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                          { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_MEDIUM_AND_ABOVE" }
                        ]
                    }),
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    console.error('API Error:', errorData);
                    throw new Error(`API ${response.status}: ${errorData?.error?.message || 'Unknown Error'}`);
                }
                const data = await response.json();

                if (data.promptFeedback?.blockReason) {
                   console.error('API blocked:', data.promptFeedback);
                   throw new Error(`Blocked by API: ${data.promptFeedback.blockReason}`);
                }

                if (data.candidates?.[0]?.content?.parts?.[0]?.text) {
                    const text = data.candidates[0].content.parts[0].text;
                    const lines = text.split('\n').map(l => l.trim()).filter(l => l.includes(SEPARATOR));
                    const reviews = lines.map(line => {
                        const parts = line.split(SEPARATOR);
                        if (parts.length === 2 && parts[0].trim().length > 15 && parts[1].trim().length > 3) {
                            return { review: parts[0].trim(), reviewer: parts[1].trim() };
                        } return null;
                    }).filter(item => item !== null);

                    if (reviews.length === 0) throw new Error("No valid reviews parsed from API response.");
                    if (reviews.length < BATCH_SIZE) console.warn(`Received ${reviews.length}/${BATCH_SIZE} reviews.`);
                    return reviews;
                } else {
                    console.error('Invalid API structure:', data);
                    throw new Error("Invalid API response structure.");
                }
            } catch (error) {
                console.error('Fetch failed:', error);
                throw error; // Re-throw to be caught by caller
            }
        }

        function animateAndDisplay(reviewObject) {
            const tl = gsap.timeline();
            const fadeOutDuration = 0.45;
            const fadeInDuration = 0.8;

            tl.to(elementsToAnimate, {
                   duration: fadeOutDuration,
                   opacity: 0,
                   y: -20, // Slightly more movement
                   scale: 0.95,
                   filter: 'blur(2px)', // Less blur
                   ease: "power2.in",
                   stagger: 0.04
               })
              .call(() => {
                   reviewRatingElement.textContent = STAR_RATING;
                   reviewTextElement.textContent = `“${reviewObject.review}”`;
                   reviewerNameElement.textContent = `— ${reviewObject.reviewer}`;
              }, null, `-=${fadeOutDuration * 0.3}`)
              .set(elementsToAnimate, { y: 20, scale: 1.05, filter: 'blur(2px)' })
              .to(elementsToAnimate, {
                   duration: fadeInDuration,
                   opacity: 1,
                   y: 0,
                   scale: 1,
                   filter: 'blur(0px)',
                   ease: "expo.out", // Smoother ease out
                   stagger: 0.07
              });
        }

        async function showNextReview() {
            if (currentBatchIndex >= localReviewsBatch.length) {
                if (nextReviewsBatch?.length > 0) {
                    localReviewsBatch = nextReviewsBatch;
                    nextReviewsBatch = null;
                    currentBatchIndex = 0;
                } else if (isFetching) {
                    return;
                } else {
                    setStatus("Rechargement des avis...");
                    isFetching = true;
                    try {
                        const batch = await fetchNewReviewsBatchInternal();
                        if (batch?.length > 0) {
                            localReviewsBatch = batch;
                            currentBatchIndex = 0;
                            hideStatus();
                        } else { throw new Error("Received empty batch on recovery."); }
                    } catch (error) {
                        setStatus(`Erreur: ${error.message}`, true);
                        if (intervalId) clearInterval(intervalId);
                        intervalId = null;
                        isFetching = false;
                        return;
                    } finally {
                         isFetching = false;
                    }
                }
            }

            if (localReviewsBatch.length > 0 && currentBatchIndex < localReviewsBatch.length) {
                // Ensure any previous status (like loading) is hidden before showing content
                 if (statusMessageElement.classList.contains('visible') && !statusMessageElement.classList.contains('error')) {
                    hideStatus();
                }
                const reviewObj = localReviewsBatch[currentBatchIndex];
                animateAndDisplay(reviewObj);

                const prefetchIndex = Math.max(0, localReviewsBatch.length - 2); // Prefetch on second to last
                if (currentBatchIndex === prefetchIndex && nextReviewsBatch === null && !isFetching) {
                     isFetching = true;
                     fetchNewReviewsBatchInternal().then(batch => {
                         if (batch?.length > 0) {
                             nextReviewsBatch = batch;
                         } else { nextReviewsBatch = null; }
                     }).catch(error => {
                        console.error("Prefetch failed:", error);
                        nextReviewsBatch = null;
                     }).finally(() => {
                        isFetching = false;
                     });
                }
                currentBatchIndex++;
            }
        }

        async function initialize() {
            setStatus("Chargement des premiers avis...");
            isFetching = true;
            try {
                const initialBatch = await fetchNewReviewsBatchInternal();
                if (initialBatch?.length > 0) {
                    localReviewsBatch = initialBatch;
                    currentBatchIndex = 0;
                    // IMPORTANT: Hide status *before* the first animation starts
                    hideStatus();
                    // Need a slight delay for hideStatus animation before starting the first review display
                    setTimeout(() => {
                         showNextReview();
                         if (intervalId) clearInterval(intervalId);
                         intervalId = setInterval(showNextReview, REVIEW_INTERVAL_MS);
                    }, 450); // Match hideStatus duration + buffer

                } else {
                    throw new Error("Initial fetch returned no reviews.");
                }
            } catch (error) {
                setStatus(`Erreur initiale: ${error.message}`, true);
                if (intervalId) clearInterval(intervalId);
                intervalId = null;
            } finally {
                isFetching = false;
            }
        }

        document.addEventListener('DOMContentLoaded', initialize);

    </script>

</body>
</html>
